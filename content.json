[{"title":"不错的zsh配置","date":"2017-08-30T09:48:52.000Z","path":"2017/08/30/不错的zsh配置/","text":"zsh的配置在网上发现的zsh的配置，记录下来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328 #color&#123;&#123;&#123; autoload colors colorsfor color in RED GREEN YELLOW BLUE MAGENTA CYAN WHITE; doeval _$color='%&#123;$terminfo[bold]$fg[$&#123;(L)color&#125;]%&#125;'eval $color='%&#123;$fg[$&#123;(L)color&#125;]%&#125;'(( count = $count + 1 ))doneFINISH=\"%&#123;$terminfo[sgr0]%&#125;\"#&#125;&#125;&#125; #命令提示符RPROMPT=$(echo \"$RED%D %T$FINISH\")PROMPT=$(echo \"$CYAN%n@$YELLOW%M:$GREEN%/$_YELLOW&gt;$FINISH \")#PROMPT=$(echo \"$BLUE%M$GREEN%/#$CYAN%n@$BLUE%M:$GREEN%/$_YELLOW&gt;&gt;&gt;$FINISH \")#标题栏、任务栏样式&#123;&#123;&#123;case $TERM in (*xterm*|*rxvt*|(dt|k|E)term)precmd () &#123; print -Pn \"\\e]0;%n@%M//%/\\a\" &#125;preexec () &#123; print -Pn \"\\e]0;%n@%M//%/\\ $1\\a\" &#125;;;esac#&#125;&#125;&#125;#编辑器export EDITOR=vim#输入法export XMODIFIERS=\"@im=ibus\"export QT_MODULE=ibusexport GTK_MODULE=ibus#关于历史纪录的配置 &#123;&#123;&#123;#历史纪录条目数量export HISTSIZE=10000#注销后保存的历史纪录条目数量export SAVEHIST=10000#历史纪录文件 export HISTFILE=~/.zhistory#以附加的方式写入历史纪录setopt INC_APPEND_HISTORY#如果连续输入的命令相同，历史纪录中只保留一个setopt HIST_IGNORE_DUPS#为历史纪录中的命令添加时间戳setopt EXTENDED_HISTORY #启用 cd 命令的历史纪录，cd -[TAB]进入历史路径setopt AUTO_PUSHD#相同的历史路径只保留一个setopt PUSHD_IGNORE_DUPS #在命令前添加空格，不将此命令添加到纪录文件中#setopt HIST_IGNORE_SPACE#&#125;&#125;&#125; #每个目录使用独立的历史纪录&#123;&#123;&#123;cd() &#123;builtin cd \"$@\" # do actual cdfc -W # write current history filelocal HISTDIR=\"$HOME/.zsh_history$PWD\" # use nested folders for historyif [ ! -d \"$HISTDIR\" ] ; then # create folder if neededmkdir -p \"$HISTDIR\"fiexport HISTFILE=\"$HISTDIR/zhistory\" # set new history filetouch $HISTFILElocal ohistsize=$HISTSIZEHISTSIZE=0 # Discard previous dir's historyHISTSIZE=$ohistsize # Prepare for new dir's historyfc -R #read from current histfile&#125;mkdir -p $HOME/.zsh_history$PWDexport HISTFILE=\"$HOME/.zsh_history$PWD/zhistory\" function allhistory &#123; cat $(find $HOME/.zsh_history -name zhistory) &#125;function convhistory &#123;sort $1 | uniq |sed 's/^:\\([ 0-9]*\\):[0-9]*;\\(.*\\)/\\1::::::\\2/' |awk -F\"::::::\" '&#123; $1=strftime(\"%Y-%m-%d %T\",$1) \"|\"; print &#125;'&#125;#使用 histall 命令查看全部历史纪录function histall &#123; convhistory =(allhistory) |sed '/^.\\&#123;20\\&#125; *cd/i\\\\' &#125;#使用 hist 查看当前目录历史纪录function hist &#123; convhistory $HISTFILE &#125; #全部历史纪录 top50function top50 &#123; allhistory | awk -F':[ 0-9]*:[0-9]*;' '&#123; $1=\"\" ; print &#125;' | sed 's/ /\\n/g' | sed '/^$/d' | sort | uniq -c | sort -nr | head -n 50 &#125; #&#125;&#125;&#125; #杂项 &#123;&#123;&#123;#允许在交互模式中使用注释 例如：#cmd #这是注释setopt INTERACTIVE_COMMENTS #启用自动 cd，输入目录名回车进入目录#稍微有点混乱，不如 cd 补全实用setopt AUTO_CD #扩展路径#/v/c/p/p =&gt; /var/cache/pacman/pkgsetopt complete_in_word #禁用 core dumpslimit coredumpsize 0 #Emacs风格 键绑定bindkey -e#bindkey -v#设置 [DEL]键 为向后删除#bindkey \"\\e[3~\" delete-char #以下字符视为单词的一部分WORDCHARS='*?_-[]~=&amp;;!#$%^()&#123;&#125;&lt;&gt;'#&#125;&#125;&#125; #自动补全功能 &#123;&#123;&#123;setopt AUTO_LISTsetopt AUTO_MENU#开启此选项，补全时会直接选中菜单项#setopt MENU_COMPLETE autoload -U compinitcompinit #自动补全缓存#zstyle ':completion::complete:*' use-cache on#zstyle ':completion::complete:*' cache-path .zcache#zstyle ':completion:*:cd:*' ignore-parents parent pwd #自动补全选项zstyle ':completion:*' verbose yeszstyle ':completion:*' menu selectzstyle ':completion:*:*:default' force-list alwayszstyle ':completion:*' select-prompt '%SSelect: lines: %L matches: %M [%p]' zstyle ':completion:*:match:*' original onlyzstyle ':completion::prefix-1:*' completer _completezstyle ':completion:predict:*' completer _completezstyle ':completion:incremental:*' completer _complete _correctzstyle ':completion:*' completer _complete _prefix _correct _prefix _match _approximate #路径补全zstyle ':completion:*' expand 'yes'zstyle ':completion:*' squeeze-shlashes 'yes'zstyle ':completion::complete:*' '\\\\' #彩色补全菜单eval $(dircolors -b)export ZLSCOLORS=\"$&#123;LS_COLORS&#125;\"zmodload zsh/complistzstyle ':completion:*' list-colors $&#123;(s.:.)LS_COLORS&#125;zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31' #修正大小写zstyle ':completion:*' matcher-list '' 'm:&#123;a-zA-Z&#125;=&#123;A-Za-z&#125;'#错误校正zstyle ':completion:*' completer _complete _match _approximatezstyle ':completion:*:match:*' original onlyzstyle ':completion:*:approximate:*' max-errors 1 numeric #kill 命令补全compdef pkill=killcompdef pkill=killallzstyle ':completion:*:*:kill:*' menu yes selectzstyle ':completion:*:*:*:*:processes' force-list alwayszstyle ':completion:*:processes' command 'ps -au$USER' #补全类型提示分组zstyle ':completion:*:matches' group 'yes'zstyle ':completion:*' group-name ''zstyle ':completion:*:options' description 'yes'zstyle ':completion:*:options' auto-description '%d'zstyle ':completion:*:descriptions' format $'\\e[01;33m -- %d --\\e[0m'zstyle ':completion:*:messages' format $'\\e[01;35m -- %d --\\e[0m'zstyle ':completion:*:warnings' format $'\\e[01;31m -- No Matches Found --\\e[0m'zstyle ':completion:*:corrections' format $'\\e[01;32m -- %d (errors: %e) --\\e[0m' # cd ~ 补全顺序zstyle ':completion:*:-tilde-:*' group-order 'named-directories' 'path-directories' 'users' 'expand'#&#125;&#125;&#125; ##行编辑高亮模式 &#123;&#123;&#123;# Ctrl+@ 设置标记，标记和光标点之间为 regionzle_highlight=(region:bg=magenta #选中区域special:bold #特殊字符isearch:underline)#搜索时使用的关键字#&#125;&#125;&#125; ##空行(光标在行首)补全 \"cd \" &#123;&#123;&#123;user-complete()&#123;case $BUFFER in\"\" ) # 空行填入 \"cd \"BUFFER=\"cd \"zle end-of-linezle expand-or-complete;;\"cd --\" ) # \"cd --\" 替换为 \"cd +\"BUFFER=\"cd +\"zle end-of-linezle expand-or-complete;;\"cd +-\" ) # \"cd +-\" 替换为 \"cd -\"BUFFER=\"cd -\"zle end-of-linezle expand-or-complete;;* )zle expand-or-complete;;esac&#125;zle -N user-completebindkey \"\\t\" user-complete#&#125;&#125;&#125; ##在命令前插入 sudo &#123;&#123;&#123;#定义功能sudo-command-line() &#123;[[ -z $BUFFER ]] &amp;&amp; zle up-history[[ $BUFFER != sudo\\ * ]] &amp;&amp; BUFFER=\"sudo $BUFFER\"zle end-of-line #光标移动到行末&#125;zle -N sudo-command-line#定义快捷键为： [Esc] [Esc]bindkey \"\\e\\e\" sudo-command-line#&#125;&#125;&#125; #命令别名 &#123;&#123;&#123;#alias cp='cp -i'#alias mv='mv -i'#alias rm='rm -i'#alias ls='ls -F --color=auto'#alias ll='ls -al'#alias grep='grep --color=auto'#alias la='ls -a'#alias pacman='sudo pacman-color'#alias p='sudo pacman-color'#alias y='yaourt'#alias h='htop'#alias vim='sudo vim' #[Esc][h] man 当前命令时，显示简短说明alias run-help &gt;&amp;/dev/null &amp;&amp; unalias run-helpautoload run-help #历史命令 top10alias top10='print -l $&#123;(o)history%% *&#125; | uniq -c | sort -nr | head -n 10'#&#125;&#125;&#125; ##for Emacs &#123;&#123;&#123;#在 Emacs终端 中使用 Zsh 的一些设置 不推荐在 Emacs 中使用它#if [[ \"$TERM\" == \"dumb\" ]]; then#setopt No_zle#PROMPT='%n@%M %/#&gt;&gt;'#alias ls='ls -F'#fi#&#125;&#125;&#125; #&#123;&#123;&#123;自定义补全#补全 pingzstyle ':completion:*:ping:*' hosts 192.168.1.&#123;1,50,51,100,101&#125; www.google.com #补全 ssh scp sftp 等#zstyle -e ':completion::*:*:*:hosts' hosts 'reply=($&#123;=$&#123;$&#123;(f)\"$(cat &#123;/etc/ssh_,~/.ssh/known_&#125;hosts(|2)(N) /dev/null)\"&#125;%%[# ]*&#125;//,/ &#125;)'#&#125;&#125;&#125; #&#123;&#123;&#123; F1 计算器arith-eval-echo() &#123;LBUFFER=\"$&#123;LBUFFER&#125;echo \\$(( \"RBUFFER=\" ))$RBUFFER\"&#125;zle -N arith-eval-echobindkey \"^[[11~\" arith-eval-echo#&#125;&#125;&#125; ####&#123;&#123;&#123;function timeconv &#123; date -d @$1 +\"%Y-%m-%d %T\" &#125; # &#125;&#125;&#125; zmodload zsh/mathfuncautoload -U zsh-mime-setupzsh-mime-setupsetopt EXTENDED_GLOB#autoload -U promptinit#promptinit#prompt redhat setopt correctallautoload compinstall #漂亮又实用的命令高亮界面setopt extended_glob TOKENS_FOLLOWED_BY_COMMANDS=('|' '||' ';' '&amp;' '&amp;&amp;' 'sudo' 'do' 'time' 'strace') recolor-cmd() &#123; region_highlight=() colorize=true start_pos=0 for arg in $&#123;(z)BUFFER&#125;; do ((start_pos+=$&#123;#BUFFER[$start_pos+1,-1]&#125;-$&#123;#$&#123;BUFFER[$start_pos+1,-1]## #&#125;&#125;)) ((end_pos=$start_pos+$&#123;#arg&#125;)) if $colorize; then colorize=false res=$(LC_ALL=C builtin type $arg 2&gt;/dev/null) case $res in *'reserved word'*) style=\"fg=magenta,bold\";; *'alias for'*) style=\"fg=cyan,bold\";; *'shell builtin'*) style=\"fg=yellow,bold\";; *'shell function'*) style='fg=green,bold';; *\"$arg is\"*) [[ $arg = 'sudo' ]] &amp;&amp; style=\"fg=red,bold\" || style=\"fg=blue,bold\";; *) style='none,bold';; esac region_highlight+=(\"$start_pos $end_pos $style\") fi [[ $&#123;$&#123;TOKENS_FOLLOWED_BY_COMMANDS[(r)$&#123;arg//|/\\|&#125;]&#125;:+yes&#125; = 'yes' ]] &amp;&amp; colorize=true start_pos=$end_pos done &#125;check-cmd-self-insert() &#123; zle .self-insert &amp;&amp; recolor-cmd &#125; check-cmd-backward-delete-char() &#123; zle .backward-delete-char &amp;&amp; recolor-cmd &#125; zle -N self-insert check-cmd-self-insert zle -N backward-delete-char check-cmd-backward-delete-char","tags":[{"name":"-shell -zsh","slug":"shell-zsh","permalink":"http://yoursite.com/tags/shell-zsh/"}]},{"title":"Shell 学习","date":"2017-08-18T08:48:31.000Z","path":"2017/08/18/Shell-学习/","text":"","tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"Xcode创建.Framework相关","date":"2017-08-01T06:56:35.000Z","path":"2017/08/01/Xcode创建Framework相关/","text":"iOS的静态库12345iOS的静态库分两种：.a和.framework; 动态库.framework静态库：链接时，静态库会被完整的复制到可执行文件中，被多次使用就有多份冗余拷贝。例如我们在程序使用友盟.a，另外一个应用也使用了友盟.a。这样整个系统里就有两个友盟.a动态库：链接时不复制，在程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。系统提供的库基本上都属于此类 参考文章： IOS合并lib(.a)库的终极可用方法(可用于解决duplicate symbol静态库冲突)","tags":[{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"}]},{"title":"hexo-常用命令","date":"2017-07-25T06:49:33.000Z","path":"2017/07/25/hexo-常用命令/","text":"Hexo 123npm install hexo - g #安装 npm update hexo - g #升级 hexo init #初始化 简写12345hexo n \"我的博客\" == hexo new \"我的博客\" #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器12345678hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动12hexo generate #使用 hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署123456两个命令的作用是相同的hexo generate --deployhexo deploy --generate----------------------------hexo deploy -ghexo server -g 草稿1hexo publish [layout] &lt;title&gt; 模板12345hexo new \"新文章\" #新建文章hexo new page \"新文章\" #新加页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口(默认端口4000,'ctrl + c' 关闭server)hexo deploy #将.deploy目录部署到Github 123hexo new [layout] &lt;title&gt;hexo new photo \"my gallery\"hexo new \"Hello World\" --lang tw 变量 描述 layout 布局 title 标题 date 文件简历日期 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 设置文章摘要1以上是文章摘要&lt;!--more--&gt; 以下是余下全文 写作12hexo new page &lt;title&gt;hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 部署123hexo clean #清理hexo g #生成hexo d #部署， #可与hexo g 合并为hexo d -g 常见问题1、RSS不显示 #####安装RSS插件1npm install hexo-generator-feed --save #####开起RSS功能编辑hexo/_config.yml,添加如下代码：1rss: /atom.xml #rss地址，默认即可","tags":[{"name":"命令行","slug":"命令行","permalink":"http://yoursite.com/tags/命令行/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}]